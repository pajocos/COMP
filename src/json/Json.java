/* Generated By:JJTree&JavaCC: Do not edit this line. Json.java */
package json;
import java.io.FileNotFoundException;
import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import graphviz.GraphViz;
import java.io.File;
import java.io.PrintWriter;
import java.util.Random;

public class Json/*@bgen(jjtree)*/implements JsonTreeConstants, JsonConstants {/*@bgen(jjtree)*/
  protected JJTJsonState jjtree = new JJTJsonState();public static boolean syntaticError = false;

  public static HashMap < Integer, Integer > groupColor;

  private static String [] edgeStyle =
  {
    "dashed", "dotted", "solid", "bold"
  }
  ;

  private static String [] nodeShapes =
  {
    "box", "polygon", "ellipse", "oval", "circle", "point", "egg", "triangle", "plaintext", "plain", "diamond", "trapezium", "parallelogram", "house", "pentagon", "hexagon", "septagon", "octagon", "doublecircle", "doubleoctagon", "tripleoctagon", "invtriangle", "invtrapezium", "invhouse", "Mdiamond", "Msquare", "Mcircle", "rect", "rectangle", "square", "star", "none", "underline", "note", "tab", "folder", "box3d", "component", "promoter", "cds", "terminator", "utr", "primersite", "restrictionsite", "fivepoverhang", "threepoverhang", "noverhang", "assembly", "signature", "insulator", "ribosite", "rnastab", "proteasesite", "proteinstab", "rpromoter", "rarrow", "larrow", "lpromoter"
  }
  ;

  private static String [] colors =
  {
    "aliceblue", "antiquewhite", "antiquewhite1", "antiquewhite2", "antiquewhite3", "antiquewhite4", "aquamarine", "aquamarine1", "aquamarine2", "aquamarine3", "aquamarine4", "azure", "azure1", "azure2", "azure3", "azure4", "beige", "bisque", "bisque1", "bisque2", "bisque3", "bisque4", "blanchedalmond", "blue", "blue1", "blue2", "blue3", "blue4", "blueviolet", "brown", "brown1", "brown2", "brown3", "brown4", "burlywood", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "cadetblue", "cadetblue1", "cadetblue2", "cadetblue3", "cadetblue4", "chartreuse", "chartreuse1", "chartreuse2", "chartreuse3", "chartreuse4", "chocolate", "chocolate1", "chocolate2", "chocolate3", "chocolate4", "coral", "coral1", "coral2", "coral3", "coral4", "cornflowerblue", "cornsilk", "cornsilk1", "cornsilk2", "cornsilk3", "cornsilk4", "crimson", "cyan", "cyan1", "cyan2", "cyan3", "cyan4", "darkgoldenrod", "darkgoldenrod1", "darkgoldenrod2", "darkgoldenrod3", "darkgoldenrod4", "darkgreen", "darkkhaki", "darkolivegreen", "darkolivegreen1", "darkolivegreen2", "darkolivegreen3", "darkolivegreen4", "darkorange", "darkorange1", "darkorange2", "darkorange3", "darkorange4", "darkorchid", "darkorchid1", "darkorchid2", "darkorchid3", "darkorchid4", "darksalmon", "darkseagreen", "darkseagreen1", "darkseagreen2", "darkseagreen3", "darkseagreen4", "darkslateblue", "darkslategray", "darkslategray1", "darkslategray2", "darkslategray3", "darkslategray4", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deeppink1", "deeppink2", "deeppink3", "deeppink4", "deepskyblue", "deepskyblue1", "deepskyblue2", "deepskyblue3", "deepskyblue4", "dimgray", "dimgrey", "dodgerblue", "dodgerblue1", "dodgerblue2", "dodgerblue3", "dodgerblue4", "firebrick", "firebrick1", "firebrick2", "firebrick3", "firebrick4", "floralwhit", "forestgreen", "gainsboro", "ghostwhite", "gold", "gold1", "gold2", "gold3", "gold4", "goldenrod", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4", "gray", "gray30", "gray31", "gray32", "gray33", "gray34", "gray35", "gray36", "gray37", "gray38", "gray39", "gray40", "gray41", "gray42", "gray48", "gray49", "gray50", "gray51", "gray52", "gray53", "gray54", "gray55", "gray56", "gray57", "gray58", "gray59", "gray60", "gray61", "gray62", "gray63", "gray64", "gray65", "gray66", "gray67", "gray68", "gray69", "gray70", "gray71", "gray72", "gray73", "gray74", "gray75", "gray76", "gray77", "gray78", "gray79", "gray80", "gray81", "gray82", "gray83", "gray84", "gray85", "gray86", "gray87", "gray88", "gray89", "gray90", "gray91", "gray92", "gray93", "gray94", "gray95", "gray96", "gray97", "gray98", "gray99", "green", "green1", "green2", "green3", "green4", "greenyellow", "honeydew", "honeydew1", "honeydew2", "honeydew3", "honeydew4", "hotpink", "hotpink", "hotpink2", "hotpink3", "hotpink4", "indianred", "indianred1", "indianred2", "indianred3", "indianred4", "indigo", "invis", "ivory", "ivory1", "ivory2", "ivory3", "ivory4", "khaki", "khaki1", "khaki2", "khaki3", "khaki4", "lavender", "lavenderblush", "lavenderblush1", "lavenderblush2", "lavenderblush3", "lavenderblush4", "lawngreen", "lemonchiffon", "lemonchiffon1", "lemonchiffon2", "lemonchiffon3", "lemonchiffon4", "lightblue", "lightblue1", "lightblue2", "lightblue3", "lightblue4", "lightcoral", "lightcyan", "lightcyan1", "lightcyan2", "lightcyan3", "lightcyan4", "lightgoldenrod", "lightgoldenrod1", "lightgoldenrod2", "lightgoldenrod3", "lightgoldenrod4", "lightgoldenrodyellow", "lightgray", "lightgrey", "lightpink", "lightpink1", "lightpink2", "lightpink4", "lightsalmon", "lightsalmon1", "lightsalmon2", "lightsalmon3", "lightsalmon4", "lightseagreen", "lightskyblue", "lightskyblue1", "lightskyblue2", "lightskyblue3", "lightskyblue4", "lightslateblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightsteelblue1", "lightsteelblue2", "lightsteelblue3", "lightsteelblue4", "lightyellow", "lightyellow1", "lightyellow2", "lightyellow3", "lightyellow4", "limegreen", "linen", "magenta", "magenta1", "magenta2", "magenta3", "magenta4", "maroon", "maroon1", "maroon2", "maroon3", "maroon4", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumorchid1", "mediumorchid2", "mediumorchid3", "mediumorchid4", "mediumpurple", "mediumpurple1", "mediumpurple2", "mediumpurple3", "mediumpurple4", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "mistyrose1", "mistyrose2", "mistyrose3", "mistyrose4", "moccasin", "navajowhite", "navajowhite1", "navajowhite2", "navajowhite3", "navajowhite4", "navy", "navyblue", "none", "oldlace", "olivedrab", "olivedrab1", "olivedrab2", "olivedrab3", "olivedrab4", "orange", "orange1", "orange2", "orange3", "orange4", "orangered", "orangered1", "orangered2", "orangered3", "orangered4", "orchid", "orchid1", "orchid2", "orchid3", "orchid4", "palegoldenrod", "palegreen", "palegreen1", "palegreen2", "palegreen3", "palegreen4", "paleturquoise", "paleturquoise1", "paleturquoise2", "paleturquoise3", "paleturquoise4", "palevioletred", "palevioletred1", "palevioletred2", "palevioletred3", "palevioletred4", "papayawhip", "peachpuff", "peachpuff1", "peachpuff2", "peachpuff3", "peachpuff4", "peru", "pink", "pink1", "pink2", "pink3", "pink4", "plum", "plum1", "plum2", "plum3", "plum4", "powderblue", "purple", "purple1", "purple2", "purple3", "purple4", "red", "red1", "red2", "red3", "red4", "rosybrown", "rosybrown1", "rosybrown2", "rosybrown3", "rosybrown4", "royalblue", "royalblue1", "royalblue2", "royalblue3", "royalblue4", "saddlebrown", "salmon", "salmon1", "salmon2", "salmon3", "salmon4", "sandybrown", "seagreen", "seagreen1", "seagreen2", "seagreen3", "seagreen4", "seashell", "seashell1", "seashell2", "seashell3", "seashell4", "sienna", "sienna1", "sienna2", "sienna3", "sienna4", "skyblue", "skyblue1", "skyblue2", "skyblue3", "skyblue4", "slateblue", "slateblue1", "slateblue2", "slateblue3", "slateblue4", "slategray", "slategray1", "slategray2", "slategray3", "slategray4", "slategrey", "snow", "snow1", "snow2", "snow3", "snow4", "springgreen", "springgreen1", "springgreen2", "springgreen3", "springgreen4", "steelblue", "steelblue1", "steelblue2", "steelblue3", "steelblue4", "tan", "tan1", "tan2", "tan3", "tan4", "thistle", "thistle1", "thistle2", "thistle3", "thistle4", "tomato", "tomato1", "tomato2", "tomato3", "tomato4", "transparent", "turquoise", "turquoise1", "turquoise2", "turquoise3", "turquoise4", "violet", "violetred", "violetred1", "violetred2", "violetred3", "violetred4", "wheat", "wheat1", "wheat2", "wheat3", "wheat4", "white", "whitesmoke", "yellow", "yellow1", "yellow2", "yellow3", "yellow4", "yellowgreen"
  }
  ;

  public static void main(String args []) throws ParseException, FileNotFoundException, UnsupportedEncodingException
  {
    syntaticError = false;
    Json json = new Json(new java.io.FileInputStream(args [0]));
    SimpleNode root = json.Expression();
    System.out.println();
    root.dump("");
    if (syntaticError)
    {
      System.out.println("\u005cnSyntatic errors!");
      return;
    }
    SimpleNode nodes = (SimpleNode) root.jjtGetChild(0); //Nó com todos os nós    SimpleNode links = (SimpleNode) root.jjtGetChild(1); //Nó com todos os links    ArrayNode [] newNodes = processNodes(nodes);
    boolean duplicatedNames = verifyNodes(newNodes);
    ArrayLink [] newLinks = processLinks(links);
    boolean errorLinks = verifyLinks(newLinks, newNodes.length);
    if (errorLinks || duplicatedNames)
    {
      System.out.println("\u005cnSemantic errors!");
      return;
    }
    int fileCreated = createDotFile(newNodes, newLinks, args [1], args [2], args [3], args [4]);
    if (fileCreated == 1) System.out.println("\u005cnFile generated successfully!");
    else System.out.println("\u005cnSomething went wrong!");
  }

  public static ArrayNode [] processNodes(SimpleNode nodes)
  {
    ArrayNode [] newNodes = new ArrayNode [nodes.jjtGetNumChildren()];
    int colorID = 0;
    groupColor = new HashMap < Integer, Integer > ();
    for (int i = 0; i < nodes.jjtGetNumChildren(); i++)
    {
      ArrayNode an = new ArrayNode();
      an.setName(nodes.jjtGetChild(i).jjtGetChild(0).getNodeValue());
      an.setGroup(Integer.parseInt(nodes.jjtGetChild(i).jjtGetChild(1).getNodeValue()));
      if (!groupColor.containsKey(Integer.parseInt(nodes.jjtGetChild(i).jjtGetChild(1).getNodeValue()))) //Nao existe o grupo      {
        Random rand = new Random();
        do
        {
          colorID = rand.nextInt(colors.length);
        }
        while (groupColor.containsValue(colorID));
        groupColor.put(Integer.parseInt(nodes.jjtGetChild(i).jjtGetChild(1).getNodeValue()), colorID);
      }
      if (nodes.jjtGetChild(i).jjtGetNumChildren() == 3)
      {
        an.setShape(nodes.jjtGetChild(i).jjtGetChild(2).getNodeValue());
      }
      an.setBeginLine(nodes.jjtGetChild(i).jjtGetChild(0).getBeginLine());
      an.setBeginColumn(nodes.jjtGetChild(i).jjtGetChild(0).getBeginColumn());
      newNodes [i] = an;
    }
    return newNodes;
  }

  public static ArrayLink [] processLinks(SimpleNode links)
  {
    ArrayLink [] newLinks = new ArrayLink [links.jjtGetNumChildren()];
    for (int i = 0; i < links.jjtGetNumChildren(); i++)
    {
      ArrayLink an = new ArrayLink();
      an.setValues(Integer.parseInt(links.jjtGetChild(i).jjtGetChild(0).getNodeValue()), Integer.parseInt(links.jjtGetChild(i).jjtGetChild(1).getNodeValue()), Integer.parseInt(links.jjtGetChild(i).jjtGetChild(2).getNodeValue()), links.jjtGetChild(i).jjtGetChild(0).getBeginLine(), links.jjtGetChild(i).jjtGetChild(0).getBeginColumn());
      if (links.jjtGetChild(i).jjtGetNumChildren() == 4)
      {
        an.setStyle(links.jjtGetChild(i).jjtGetChild(3).getNodeValue());
      }
      newLinks [i] = an;
    }
    return newLinks;
  }

  public static boolean verifyNodes(ArrayNode [] nodes)
  {
    Set < String > tempSet = new HashSet < String > ();
    boolean error = false;
    for (int i = 0; i < nodes.length; i++)
    {
      boolean existShape = false;
      String str = nodes [i].getName();
      if (!tempSet.add(str))
      {
        System.out.println("Duplicated name: " + str + " at line " + nodes [i].getBeginLine() + " column " + nodes [i].getBeginColumn());
        error = true;
      }
      for (int j = 0; j < nodeShapes.length; j++)
      {
        if (nodes [i].getShape().equals("\u005c"" + nodeShapes [j] + "\u005c""))
        {
          existShape = true;
        }
      }
      if (!existShape && !nodes [i].getShape().equals(""))
      {
        System.out.println("Unknown shape: " + nodes [i].getShape() + " at line " + nodes [i].getBeginLine() + " column " + nodes [i].getBeginColumn());
        error = true;
      }
    }
    return error;
  }

  public static boolean verifyLinks(ArrayLink [] links, int numNodes)
  {
    boolean error = false;
    for (int i = 0; i < links.length; i++)
    {
      boolean existStyle = false;
      int source = links [i].getSource();
      int target = links [i].getTarget();
      if (source >= numNodes || target >= numNodes) //Verifica se os nos de origem e destino existem      {
        error = true;
        System.out.println("Source or target node inexistent at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());
      }
      if (source == target) //Verifica se o no de origem e de destino sao o mesmo      {
        error = true;
        System.out.println("Same source and target nodes at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());
      }
      for (int j = i + 1; j < links.length; j++) //Verifica se ha ligaçoes duplicadas      {
        if (links [i].getSource() == links [j].getSource() && links [i].getTarget() == links [j].getTarget())
        {
          error = true;
          System.out.println("Duplicated link at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());
        }
      }
      for (int k = 0; k < edgeStyle.length; k++)
      {
        if (links [i].getStyle().equals("\u005c"" + edgeStyle [k] + "\u005c""))
        {
          existStyle = true;
        }
      }
      if (!existStyle && !links [i].getStyle().equals(""))
      {
        error = true;
        System.out.println("Link style doesn't exist at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());
      }
    }
    return error;
  }

  public static int createDotFile(ArrayNode [] nodes, ArrayLink [] links, String savePath, String saveName, String type, String graphvizPath) throws FileNotFoundException, UnsupportedEncodingException
  {
    int success = 0;
    GraphViz gv = new GraphViz();
    gv.addln(gv.start_graph());
    for (int i = 0; i < nodes.length; i++)
    {
      String nodeString = nodes [i].getName() + "[color=\u005c"" + colors [groupColor.get(nodes [i].getGroup())] + "\u005c" style=filled";
      System.out.println(colors [groupColor.get(nodes [i].getGroup())]);
      if (!nodes [i].getShape().equals(""))
      {
        nodeString += " shape=" + nodes [i].getShape();
      }
      nodeString += "];";
      gv.addln(nodeString);
    }
    for (int i = 0; i < links.length; i++)
    {
      String line = nodes [links [i].getSource()].getName() + " -> " + nodes [links [i].getTarget()].getName() + " [label = " + links [i].getValue();
      if (!links [i].getStyle().equals(""))
      {
        line += ", style=" + links [i].getStyle();
      }
      line += "] ;";
      gv.addln(line);
    }
    gv.addln(gv.end_graph());
    File out = new File(savePath + "\u005c\u005c" + saveName + "." + type);
    File tempFolder = new File(savePath + "\u005c\u005ctemp_D3fdg2Dot");
    GraphViz.setTEMP_DIR(savePath + "\u005c\u005ctemp_D3fdg2Dot");
    GraphViz.setDOT(graphvizPath);
    if (tempFolder.mkdirs() && !graphvizPath.equals(""))
    {
      success = gv.writeGraphToFile(gv.getGraph(gv.getDotSource(), type), out);
      tempFolder.delete();
    }
    else
    {
      PrintWriter writer = new PrintWriter(savePath + "\u005c\u005c" + saveName + "." + type, "UTF-8");
      writer.println(gv.getDotSource());
      writer.close();
      success = 1;
      tempFolder.delete();
    }
    return success;
  }

  final public SimpleNode Expression() throws ParseException {
 /*@bgen(jjtree) Start_Exp */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART_EXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression1();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void Expression1() throws ParseException {
    try {
      jj_consume_token(OBRACKET);
      jj_consume_token(NODES);
      jj_consume_token(TD);
      jj_consume_token(OBRA);
      Expression2();
      jj_consume_token(CBRA);
      jj_consume_token(COMMA);
      jj_consume_token(LINKS);
      jj_consume_token(TD);
      jj_consume_token(OBRA);
      Expression3();
      jj_consume_token(CBRA);
      jj_consume_token(CBRACKET);
    } catch (ParseException e) {
    error_skipto(CBRACKET);
    }
  }

  final public void Expression2() throws ParseException {
 /*@bgen(jjtree) nodes */
  SimpleNode jjtn000 = new SimpleNode(JJTNODES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression4();
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        jj_consume_token(COMMA);
        Expression4();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Expression3() throws ParseException {
 /*@bgen(jjtree) links */
  SimpleNode jjtn000 = new SimpleNode(JJTLINKS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression5();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        Expression5();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Expression4() throws ParseException {
 /*@bgen(jjtree) node */
  SimpleNode jjtn000 = new SimpleNode(JJTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      try {
        jj_consume_token(OBRACKET);
        jj_consume_token(NAME);
        jj_consume_token(TD);
        Expression6();
        jj_consume_token(COMMA);
        jj_consume_token(GROUP);
        jj_consume_token(TD);
        Expression7();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          jj_consume_token(SHAPE);
          jj_consume_token(TD);
          Expression6();
          break;
        default:
          jj_la1[2] = jj_gen;
          ;
        }
        jj_consume_token(CBRACKET);
      } catch (ParseException e) {
    error_skipto(CBRACKET);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Expression5() throws ParseException {
 /*@bgen(jjtree) link */
  SimpleNode jjtn000 = new SimpleNode(JJTLINK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      try {
        jj_consume_token(OBRACKET);
        jj_consume_token(SOURCE);
        jj_consume_token(TD);
        Expression7();
        jj_consume_token(COMMA);
        jj_consume_token(TARGET);
        jj_consume_token(TD);
        Expression7();
        jj_consume_token(COMMA);
        jj_consume_token(VALUE);
        jj_consume_token(TD);
        Expression7();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          jj_consume_token(STYLE);
          jj_consume_token(TD);
          Expression6();
          break;
        default:
          jj_la1[3] = jj_gen;
          ;
        }
        jj_consume_token(CBRACKET);
      } catch (ParseException e) {
    error_skipto(CBRACKET);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Expression6() throws ParseException {
  Token t;
    SimpleNode jjtn001 = new SimpleNode(JJTLETTER);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    try {
      t = jj_consume_token(LETTER);
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
    }
    jjtn001.setValues(t);
  }

  final public void Expression7() throws ParseException {
  Token t;
    SimpleNode jjtn001 = new SimpleNode(JJTINT);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    try {
      t = jj_consume_token(INTEGER);
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
    }
    jjtn001.setValues(t);
  }

  void error_skipto(int kind) throws ParseException {
 /*@bgen(jjtree) SyntaticError */
SimpleNode jjtn000 = new SimpleNode(JJTSYNTATICERROR);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {Json.syntaticError = true;
  ParseException e = generateParseException()
; // generate the exception object.System.out.println("Error found at column "+ e.currentToken.beginColumn+ " line "+ e.currentToken.beginLine);
Token t;
do
{
  t = getNextToken();
  if (t.kind == CBRA) return;
}

while (t.kind != kind);/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
  }

  /** Generated Token Manager. */
  public JsonTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[4];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x400000,0x400000,0x400000,0x400000,};
   }

  /** Constructor with InputStream. */
  public Json(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Json(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new JsonTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 4; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 4; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Json(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new JsonTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 4; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 4; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Json(JsonTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 4; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(JsonTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 4; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[23];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 4; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 23; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
