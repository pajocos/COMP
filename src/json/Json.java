/* Generated By:JJTree&JavaCC: Do not edit this line. Json.java */
package json;
import java.io.FileNotFoundException;
import java.io.UnsupportedEncodingException;
import java.util.HashSet;
import java.util.Set;
import graphviz.GraphViz;
import java.io.File;
import java.io.PrintWriter;

public class Json/*@bgen(jjtree)*/implements JsonTreeConstants, JsonConstants {/*@bgen(jjtree)*/
  protected JJTJsonState jjtree = new JJTJsonState();private static String [] edgeStyle =
  {
    "dashed", "dotted", "solid", "bold"
  }
  ;

  private static String [] nodeShapes =
  {
    "box", "polygon", "ellipse", "oval", "circle", "point", "egg", "triangle", "plaintext", "plain", "diamond", "trapezium", "parallelogram", "house", "pentagon", "hexagon", "septagon", "octagon", "doublecircle", "doubleoctagon", "tripleoctagon", "invtriangle", "invtrapezium", "invhouse", "Mdiamond", "Msquare", "Mcircle", "rect", "rectangle", "square", "star", "none", "underline", "note", "tab", "folder", "box3d", "component", "promoter", "cds", "terminator", "utr", "primersite", "restrictionsite", "fivepoverhang", "threepoverhang", "noverhang", "assembly", "signature", "insulator", "ribosite", "rnastab", "proteasesite", "proteinstab", "rpromoter", "rarrow", "larrow", "lpromoter"
  }
  ;

  public static void main(String args []) throws ParseException, FileNotFoundException, UnsupportedEncodingException
  {
    Json json = new Json(new java.io.FileInputStream(args [0]));
    SimpleNode root = json.Expression();
    root.dump("");
    SimpleNode nodes = (SimpleNode) root.jjtGetChild(0); //Nó com todos os nós    SimpleNode links = (SimpleNode) root.jjtGetChild(1); //Nó com todos os links    ArrayNode [] newNodes = processNodes(nodes);
    boolean duplicatedNames = verifyNodes(newNodes);
    ArrayLink [] newLinks = processLinks(links);
    boolean errorLinks = verifyLinks(newLinks, newNodes.length);
    if (errorLinks || duplicatedNames)
    {
      System.out.println("Semantic errors!");
      return;
    }
    int fileCreated = createDotFile(newNodes, newLinks, args [1], args [2], args [3], args [4]);
    if (fileCreated == 1) System.out.println("File generated successfully!");
    else System.out.println("Something went wrong!");
  }

  public static ArrayNode [] processNodes(SimpleNode nodes)
  {
    ArrayNode [] newNodes = new ArrayNode [nodes.jjtGetNumChildren()];
    for (int i = 0; i < nodes.jjtGetNumChildren(); i++)
    {
      ArrayNode an = new ArrayNode();
      an.setName(nodes.jjtGetChild(i).jjtGetChild(0).getNodeValue());
      an.setGroup(Integer.parseInt(nodes.jjtGetChild(i).jjtGetChild(1).getNodeValue()));
      if (nodes.jjtGetChild(i).jjtGetNumChildren() == 3)
      {
        an.setShape(nodes.jjtGetChild(i).jjtGetChild(2).getNodeValue());
      }
      an.setBeginLine(nodes.jjtGetChild(i).jjtGetChild(0).getBeginLine());
      an.setBeginColumn(nodes.jjtGetChild(i).jjtGetChild(0).getBeginColumn());
      newNodes [i] = an;
    }
    return newNodes;
  }

  public static ArrayLink [] processLinks(SimpleNode links)
  {
    ArrayLink [] newLinks = new ArrayLink [links.jjtGetNumChildren()];
    for (int i = 0; i < links.jjtGetNumChildren(); i++)
    {
      ArrayLink an = new ArrayLink();
      an.setValues(Integer.parseInt(links.jjtGetChild(i).jjtGetChild(0).getNodeValue()), Integer.parseInt(links.jjtGetChild(i).jjtGetChild(1).getNodeValue()), Integer.parseInt(links.jjtGetChild(i).jjtGetChild(2).getNodeValue()), links.jjtGetChild(i).jjtGetChild(0).getBeginLine(), links.jjtGetChild(i).jjtGetChild(0).getBeginColumn());
      if (links.jjtGetChild(i).jjtGetNumChildren() == 4)
      {
        an.setStyle(links.jjtGetChild(i).jjtGetChild(3).getNodeValue());
      }
      newLinks [i] = an;
    }
    return newLinks;
  }

  public static boolean verifyNodes(ArrayNode [] nodes)
  {
    Set < String > tempSet = new HashSet < String > ();
    boolean error = false;
    for (int i = 0; i < nodes.length; i++)
    {
      boolean existShape = false;
      String str = nodes [i].getName();
      if (!tempSet.add(str))
      {
        System.out.println("Duplicated name: " + str + " at line " + nodes [i].getBeginLine() + " column " + nodes [i].getBeginColumn());
        error = true;
      }
      for (int j = 0; j < nodeShapes.length; j++)
      {
        if (nodes [i].getShape().equals("\u005c"" + nodeShapes [j] + "\u005c""))
        {
          existShape = true;
        }
      }
      if (!existShape && !nodes [i].getShape().equals(""))
      {
        System.out.println("Unknown shape: " + nodes [i].getShape() + " at line " + nodes [i].getBeginLine() + " column " + nodes [i].getBeginColumn());
        error = true;
      }
    }
    return error;
  }

  public static boolean verifyLinks(ArrayLink [] links, int numNodes)
  {
    boolean error = false;
    for (int i = 0; i < links.length; i++)
    {
      boolean existStyle = false;
      int source = links [i].getSource();
      int target = links [i].getTarget();
      if (source >= numNodes || target >= numNodes) //Verifica se os nos de origem e destino existem      {
        error = true;
        System.out.println("Source or target node inexistent at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());
      }
      if (source == target) //Verifica se o no de origem e de destino sao o mesmo      {
        error = true;
        System.out.println("Same source and target nodes at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());
      }
      for (int j = i + 1; j < links.length; j++) //Verifica se ha ligaçoes duplicadas      {
        if (links [i].getSource() == links [j].getSource() && links [i].getTarget() == links [j].getTarget())
        {
          error = true;
          System.out.println("Duplicated link at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());
        }
      }
      for (int k = 0; k < edgeStyle.length; k++)
      {
        if (links [i].getStyle().equals("\u005c"" + edgeStyle [k] + "\u005c""))
        {
          existStyle = true;
        }
      }
      if (!existStyle && !links [i].getStyle().equals(""))
      {
        error = true;
        System.out.println("Link style doesn't exist at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());
      }
    }
    return error;
  }

  public static int createDotFile(ArrayNode [] nodes, ArrayLink [] links, String savePath, String saveName, String type, String graphvizPath) throws FileNotFoundException, UnsupportedEncodingException
  {
    int success = 0;
    GraphViz gv = new GraphViz();
    gv.addln(gv.start_graph());
    for (int i = 0; i < nodes.length; i++)
    {
      if (!nodes [i].getShape().equals(""))
      {
        gv.addln(nodes [i].getName() + " [shape=" + nodes [i].getShape() + "];");
      }
    }
    for (int i = 0; i < links.length; i++)
    {
      String line = nodes [links [i].getSource()].getName() + " -> " + nodes [links [i].getTarget()].getName() + " [label = " + links [i].getValue();
      if (!links [i].getStyle().equals(""))
      {
        line += ", style=" + links [i].getStyle();
      }
      line += "] ;";
      gv.addln(line);
    }
    gv.addln(gv.end_graph());
    File out = new File(savePath + "\u005c\u005c" + saveName + "." + type);
    File tempFolder = new File(savePath + "\u005c\u005ctemp_D3fdg2Dot");
    GraphViz.setTEMP_DIR(savePath + "\u005c\u005ctemp_D3fdg2Dot");
    GraphViz.setDOT(graphvizPath);
    if (tempFolder.mkdirs() && !graphvizPath.equals(""))
    {
      success = gv.writeGraphToFile(gv.getGraph(gv.getDotSource(), type), out);
      tempFolder.delete();
    }
    else
    {
      PrintWriter writer = new PrintWriter(savePath + "\u005c\u005c" + saveName + "." + type, "UTF-8");
      writer.println(gv.getDotSource());
      writer.close();
      success = 1;
      tempFolder.delete();
    }
    return success;
  }

  final public SimpleNode Expression() throws ParseException {
 /*@bgen(jjtree) Start_Exp */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART_EXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression1();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void Expression1() throws ParseException {
    jj_consume_token(OBRACKET);
    jj_consume_token(NODES);
    jj_consume_token(TD);
    jj_consume_token(OBRA);
    Expression2();
    jj_consume_token(CBRA);
    jj_consume_token(COMMA);
    jj_consume_token(LINKS);
    jj_consume_token(TD);
    jj_consume_token(OBRA);
    Expression3();
    jj_consume_token(CBRA);
    jj_consume_token(CBRACKET);
  }

  final public void Expression2() throws ParseException {
 /*@bgen(jjtree) nodes */
  SimpleNode jjtn000 = new SimpleNode(JJTNODES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression4();
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        jj_consume_token(COMMA);
        Expression4();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Expression3() throws ParseException {
 /*@bgen(jjtree) links */
  SimpleNode jjtn000 = new SimpleNode(JJTLINKS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression5();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        Expression5();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Expression4() throws ParseException {
 /*@bgen(jjtree) node */
  SimpleNode jjtn000 = new SimpleNode(JJTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(OBRACKET);
      jj_consume_token(NAME);
      jj_consume_token(TD);
      Expression6();
      jj_consume_token(COMMA);
      jj_consume_token(GROUP);
      jj_consume_token(TD);
      Expression7();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        jj_consume_token(SHAPE);
        jj_consume_token(TD);
        Expression6();
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
      jj_consume_token(CBRACKET);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Expression5() throws ParseException {
 /*@bgen(jjtree) link */
  SimpleNode jjtn000 = new SimpleNode(JJTLINK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(OBRACKET);
      jj_consume_token(SOURCE);
      jj_consume_token(TD);
      Expression7();
      jj_consume_token(COMMA);
      jj_consume_token(TARGET);
      jj_consume_token(TD);
      Expression7();
      jj_consume_token(COMMA);
      jj_consume_token(VALUE);
      jj_consume_token(TD);
      Expression7();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        jj_consume_token(STYLE);
        jj_consume_token(TD);
        Expression6();
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      jj_consume_token(CBRACKET);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Expression6() throws ParseException {
  Token t;
    SimpleNode jjtn001 = new SimpleNode(JJTLETTER);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    try {
      t = jj_consume_token(LETTER);
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
    }
    jjtn001.setValues(t);
  }

  final public void Expression7() throws ParseException {
  Token t;
    SimpleNode jjtn001 = new SimpleNode(JJTINT);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    try {
      t = jj_consume_token(INTEGER);
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
    }
    jjtn001.setValues(t);
  }

  void error_skipto(int kind) throws ParseException {
 /*@bgen(jjtree) error_skipto */
SimpleNode jjtn000 = new SimpleNode(JJTERROR_SKIPTO);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {ParseException e = generateParseException(); // generate the exception object.  System.out.println
  (
    e.toString()
  )
  ;
  Token t;
  do
  {
    t = getNextToken();
  }
  while (t.kind != kind);/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
  }

  /** Generated Token Manager. */
  public JsonTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[4];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x400000,0x400000,0x400000,0x400000,};
   }

  /** Constructor with InputStream. */
  public Json(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Json(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new JsonTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 4; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 4; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Json(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new JsonTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 4; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 4; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Json(JsonTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 4; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(JsonTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 4; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[23];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 4; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 23; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
