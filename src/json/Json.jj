/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Json.jj */
/*@egen*/options{  LOOKAHEAD= 1;  STATIC = false;}PARSER_BEGIN(Json)package json;import java.io.FileNotFoundException;import java.io.UnsupportedEncodingException;import java.util.HashSet;import java.util.Set;import graphviz.GraphViz;import java.io.File;import java.io.PrintWriter;public class Json/*@bgen(jjtree)*/implements JsonTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTJsonState jjtree = new JJTJsonState();

/*@egen*/  private static String [] edgeStyle =  {    "dashed", "dotted", "solid", "bold"  }  ;  private static String [] nodeShapes =  {    "box", "polygon", "ellipse", "oval", "circle", "point", "egg", "triangle", "plaintext", "plain", "diamond", "trapezium", "parallelogram", "house", "pentagon", "hexagon", "septagon", "octagon", "doublecircle", "doubleoctagon", "tripleoctagon", "invtriangle", "invtrapezium", "invhouse", "Mdiamond", "Msquare", "Mcircle", "rect", "rectangle", "square", "star", "none", "underline", "note", "tab", "folder", "box3d", "component", "promoter", "cds", "terminator", "utr", "primersite", "restrictionsite", "fivepoverhang", "threepoverhang", "noverhang", "assembly", "signature", "insulator", "ribosite", "rnastab", "proteasesite", "proteinstab", "rpromoter", "rarrow", "larrow", "lpromoter"  }  ;  public static void main(String args []) throws ParseException, FileNotFoundException, UnsupportedEncodingException  {    Json json = new Json(new java.io.FileInputStream(args [0]));    SimpleNode root = json.Expression();    root.dump("");    SimpleNode nodes = (SimpleNode) root.jjtGetChild(0); //N\u00f3 com todos os n\u00f3s    SimpleNode links = (SimpleNode) root.jjtGetChild(1); //N\u00f3 com todos os links    ArrayNode [] newNodes = processNodes(nodes);    boolean duplicatedNames = verifyNodes(newNodes);    ArrayLink [] newLinks = processLinks(links);    boolean errorLinks = verifyLinks(newLinks, newNodes.length);    if (errorLinks || duplicatedNames)    {      System.out.println("Semantic errors!");      return;    }    int fileCreated = createDotFile(newNodes, newLinks, args [1], args [2], args [3], args [4]);    if (fileCreated == 1) System.out.println("File generated successfully!");    else System.out.println("Something went wrong!");  }  public static ArrayNode [] processNodes(SimpleNode nodes)  {    ArrayNode [] newNodes = new ArrayNode [nodes.jjtGetNumChildren()];    for (int i = 0; i < nodes.jjtGetNumChildren(); i++)    {      ArrayNode an = new ArrayNode();      an.setName(nodes.jjtGetChild(i).jjtGetChild(0).getNodeValue());      an.setGroup(Integer.parseInt(nodes.jjtGetChild(i).jjtGetChild(1).getNodeValue()));      if (nodes.jjtGetChild(i).jjtGetNumChildren() == 3)      {        an.setShape(nodes.jjtGetChild(i).jjtGetChild(2).getNodeValue());      }      an.setBeginLine(nodes.jjtGetChild(i).jjtGetChild(0).getBeginLine());      an.setBeginColumn(nodes.jjtGetChild(i).jjtGetChild(0).getBeginColumn());      newNodes [i] = an;    }    return newNodes;  }  public static ArrayLink [] processLinks(SimpleNode links)  {    ArrayLink [] newLinks = new ArrayLink [links.jjtGetNumChildren()];    for (int i = 0; i < links.jjtGetNumChildren(); i++)    {      ArrayLink an = new ArrayLink();      an.setValues(Integer.parseInt(links.jjtGetChild(i).jjtGetChild(0).getNodeValue()), Integer.parseInt(links.jjtGetChild(i).jjtGetChild(1).getNodeValue()), Integer.parseInt(links.jjtGetChild(i).jjtGetChild(2).getNodeValue()), links.jjtGetChild(i).jjtGetChild(0).getBeginLine(), links.jjtGetChild(i).jjtGetChild(0).getBeginColumn());      if (links.jjtGetChild(i).jjtGetNumChildren() == 4)      {        an.setStyle(links.jjtGetChild(i).jjtGetChild(3).getNodeValue());      }      newLinks [i] = an;    }    return newLinks;  }  public static boolean verifyNodes(ArrayNode [] nodes)  {    Set < String > tempSet = new HashSet < String > ();    boolean error = false;    for (int i = 0; i < nodes.length; i++)    {      boolean existShape = false;      String str = nodes [i].getName();      if (!tempSet.add(str))      {        System.out.println("Duplicated name: " + str + " at line " + nodes [i].getBeginLine() + " column " + nodes [i].getBeginColumn());        error = true;      }      for (int j = 0; j < nodeShapes.length; j++)      {        if (nodes [i].getShape().equals("\"" + nodeShapes [j] + "\""))        {          existShape = true;        }      }      if (!existShape && !nodes [i].getShape().equals(""))      {        System.out.println("Unknown shape: " + nodes [i].getShape() + " at line " + nodes [i].getBeginLine() + " column " + nodes [i].getBeginColumn());        error = true;      }    }    return error;  }  public static boolean verifyLinks(ArrayLink [] links, int numNodes)  {    boolean error = false;    for (int i = 0; i < links.length; i++)    {      boolean existStyle = false;      int source = links [i].getSource();      int target = links [i].getTarget();      if (source >= numNodes || target >= numNodes) //Verifica se os nos de origem e destino existem      {        error = true;        System.out.println("Source or target node inexistent at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());      }      if (source == target) //Verifica se o no de origem e de destino sao o mesmo      {        error = true;        System.out.println("Same source and target nodes at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());      }      for (int j = i + 1; j < links.length; j++) //Verifica se ha liga\u00e7oes duplicadas      {        if (links [i].getSource() == links [j].getSource() && links [i].getTarget() == links [j].getTarget())        {          error = true;          System.out.println("Duplicated link at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());        }      }      for (int k = 0; k < edgeStyle.length; k++)      {        if (links [i].getStyle().equals("\"" + edgeStyle [k] + "\""))        {          existStyle = true;        }      }      if (!existStyle && !links [i].getStyle().equals(""))      {        error = true;        System.out.println("Link style doesn't exist at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());      }    }    return error;  }  public static int createDotFile(ArrayNode [] nodes, ArrayLink [] links, String savePath, String saveName, String type, String graphvizPath) throws FileNotFoundException, UnsupportedEncodingException  {    int success = 0;    GraphViz gv = new GraphViz();    gv.addln(gv.start_graph());    for (int i = 0; i < nodes.length; i++)    {      if (!nodes [i].getShape().equals(""))      {        gv.addln(nodes [i].getName() + " [shape=" + nodes [i].getShape() + "];");      }    }    for (int i = 0; i < links.length; i++)    {      String line = nodes [links [i].getSource()].getName() + " -> " + nodes [links [i].getTarget()].getName() + " [label = " + links [i].getValue();      if (!links [i].getStyle().equals(""))      {        line += ", style=" + links [i].getStyle();      }      line += "] ;";      gv.addln(line);    }    gv.addln(gv.end_graph());    File out = new File(savePath + "\\" + saveName + "." + type);    File tempFolder = new File(savePath + "\\temp_D3fdg2Dot");    GraphViz.setTEMP_DIR(savePath + "\\temp_D3fdg2Dot");    GraphViz.setDOT(graphvizPath);    if (tempFolder.mkdirs() && !graphvizPath.equals(""))    {      success = gv.writeGraphToFile(gv.getGraph(gv.getDotSource(), type), out);      tempFolder.delete();    }    else    {      PrintWriter writer = new PrintWriter(savePath + "\\" + saveName + "." + type, "UTF-8");      writer.println(gv.getDotSource());      writer.close();      success = 1;      tempFolder.delete();    }    return success;  }}PARSER_END(Json)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN :{  < NODES : "\"nodes\"" >| < LINKS : "\"links\"" >| < NAME : "\"name\"" >| < GROUP : "\"group\"" >| < SOURCE : "\"source\"" >| < TARGET : "\"target\"" >| < VALUE : "\"value\"" >| < QUOTE : "\"" >| < SHAPE : "\"shape\"" > //Forma de um n\u00f3 - opcional| < STYLE : "\"style\"" > //Aresta - opcional | < INTEGER : ([ "0"-"9" ])+ >| < LETTER : ([ "\"", ".", "a"-"z", "A"-"Z", "0"-"9" ])+ >| < OBRACKET : "{" >| < CBRACKET : "}" >| < OBRA : "[" >| < CBRA : "]" >| < TD : ":" >| < COMMA : "," >}SimpleNode Expression()            :{/*@bgen(jjtree) Start_Exp */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART_EXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Start_Exp */
  try {
/*@egen*/  Expression1()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void Expression1()       :{}{  < OBRACKET > < NODES > < TD > < OBRA > Expression2() < CBRA > < COMMA > < LINKS > < TD > < OBRA > Expression3() < CBRA > < CBRACKET >}void Expression2()        :{/*@bgen(jjtree) nodes */
  SimpleNode jjtn000 = new SimpleNode(JJTNODES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) nodes */
  try {
/*@egen*/  Expression4()  (    < COMMA > Expression4()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void Expression3()        :{/*@bgen(jjtree) links */
  SimpleNode jjtn000 = new SimpleNode(JJTLINKS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) links */
  try {
/*@egen*/  Expression5()  (    < COMMA > Expression5()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void Expression4()       :{/*@bgen(jjtree) node */
  SimpleNode jjtn000 = new SimpleNode(JJTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) node */
  try {
/*@egen*/  < OBRACKET > < NAME > < TD > Expression6() < COMMA > < GROUP > < TD > Expression7()  (    < COMMA > < SHAPE > < TD > Expression6()  )?  < CBRACKET >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void Expression5()       :{/*@bgen(jjtree) link */
  SimpleNode jjtn000 = new SimpleNode(JJTLINK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) link */
  try {
/*@egen*/  < OBRACKET > < SOURCE > < TD > Expression7() < COMMA > < TARGET > < TD > Expression7() < COMMA > < VALUE > < TD > Expression7()  (    < COMMA > < STYLE > < TD > Expression6()  )?  < CBRACKET >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void Expression6()       :{  Token t;}{/*@bgen(jjtree) Letter */
  {
    SimpleNode jjtn001 = new SimpleNode(JJTLETTER);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/  t = < LETTER >/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/          {    jjtn000.setValues(t);  }}void Expression7()       :{  Token t;}{/*@bgen(jjtree) Int */
  {
    SimpleNode jjtn001 = new SimpleNode(JJTINT);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/  t = < INTEGER >/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/       {    jjtn000.setValues(t);  }}JAVACODE void error_skipto(int kind){/*@bgen(jjtree) error_skipto */
SimpleNode jjtn000 = new SimpleNode(JJTERROR_SKIPTO);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {
/*@egen*/  ParseException e = generateParseException(); // generate the exception object.  System.out.println  (    e.toString()  )  ;  Token t;  do  {    t = getNextToken();  }  while (t.kind != kind);/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/}