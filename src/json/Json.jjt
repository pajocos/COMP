options{  LOOKAHEAD= 1;  STATIC = false;}PARSER_BEGIN(Json)package json;import java.io.FileNotFoundException;import java.util.HashSet;import java.util.Set;import graphviz.GraphViz;import java.io.File;public class Json{  public static void main(String args []) throws ParseException, FileNotFoundException  {    Json json = new Json(new java.io.FileInputStream(args [0]));    SimpleNode root = json.Expression();    root.dump("");    SimpleNode nodes = (SimpleNode) root.jjtGetChild(0);    SimpleNode links = (SimpleNode) root.jjtGetChild(1);    ArrayNode [] newNodes = processNodes(nodes);    boolean duplicatedNames = verifyDuplicatedNames(newNodes);    ArrayLink [] newLinks = processLinks(links);    boolean errorLinks = verifyLinks(newLinks, newNodes.length);    if (errorLinks || duplicatedNames)    {      System.out.println("Semantic errors!");      return;    }    int file = createDotFile(newNodes, newLinks, "");    if (file == 1) System.out.println("File generated successfully!");  }  public static ArrayNode [] processNodes(SimpleNode nodes)  {    ArrayNode [] newNodes = new ArrayNode [nodes.jjtGetNumChildren()];    for (int i = 0; i < nodes.jjtGetNumChildren(); i++)    {      ArrayNode an = new ArrayNode();      an.setName(nodes.jjtGetChild(i).jjtGetChild(0).getNodeValue());      an.setGroup(Integer.parseInt(nodes.jjtGetChild(i).jjtGetChild(1).getNodeValue()));      an.setBeginLine(nodes.jjtGetChild(i).jjtGetChild(0).getBeginLine());      an.setBeginColumn(nodes.jjtGetChild(i).jjtGetChild(0).getBeginColumn());      newNodes [i] = an;    }    return newNodes;  }  public static ArrayLink [] processLinks(SimpleNode links)  {    ArrayLink [] newLinks = new ArrayLink [links.jjtGetNumChildren()];    for (int i = 0; i < links.jjtGetNumChildren(); i++)    {      ArrayLink an = new ArrayLink();      an.setValues(Integer.parseInt(links.jjtGetChild(i).jjtGetChild(0).getNodeValue()), Integer.parseInt(links.jjtGetChild(i).jjtGetChild(1).getNodeValue()), Integer.parseInt(links.jjtGetChild(i).jjtGetChild(2).getNodeValue()), links.jjtGetChild(i).jjtGetChild(0).getBeginLine(), links.jjtGetChild(i).jjtGetChild(0).getBeginColumn());      newLinks [i] = an;    }    return newLinks;  }  public static boolean verifyDuplicatedNames(ArrayNode [] nodes)  {    Set < String > tempSet = new HashSet < String > ();    boolean duplicated = false;    for (int i = 0; i < nodes.length; i++)    {      String str = nodes [i].getName();      if (!tempSet.add(str))      {        System.out.println("Duplicated name: " + str + " at line " + nodes [i].getBeginLine() + " column " + nodes [i].getBeginColumn());        duplicated = true;      }    }    return duplicated;  }  public static boolean verifyLinks(ArrayLink [] links, int numNodes)  {    boolean error = false;    for (int i = 0; i < links.length; i++)    {      int source = links [i].getSource();      int target = links [i].getTarget();      if (source >= numNodes || target >= numNodes) //Verifica se os nos de origem e destino existem      {        error = true;        System.out.println("Source or target node inexistent at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());      }      if (source == target) //Verifica se o no de origem e de destino sao o mesmo      {        error = true;        System.out.println("Same source and target nodes at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());      }      for (int j = i + 1; j < links.length; j++)      {        if (links [i].getSource() == links [j].getSource() && links [i].getTarget() == links [j].getTarget())        {          error = true;          System.out.println("Same source and target nodes at line " + links [i].getBeginLine() + " column " + links [i].getBeginColumn());        }      }    }    return error;  }  public static int createDotFile(ArrayNode [] nodes, ArrayLink [] links, String savePath)  {    int success = 0;    GraphViz gv = new GraphViz();    gv.addln(gv.start_graph());    for (int i = 0; i < links.length; i++)    {      gv.addln(nodes [links [i].getSource()].getName() + " -> " + nodes [links [i].getTarget()].getName() + " [label = " + links [i].getValue() + "] ;");    }    gv.addln(gv.end_graph());    System.out.println("\n\n" + gv.getDotSource());    String type = "png";    File out = new File("d:/graph." + type);    success = gv.writeGraphToFile(gv.getGraph(gv.getDotSource(), type), out);    return success;  } }PARSER_END(Json)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN :{  < NODES : "\"nodes\"" >| < LINKS : "\"links\"" >| < NAME : "\"name\"" >| < GROUP : "\"group\"" >| < SOURCE : "\"source\"" >| < TARGET : "\"target\"" >| < VALUE : "\"value\"" >| < INTEGER : ([ "0"-"9" ])+ >| < LETTER : ([ "\"", ".", "a"-"z", "A"-"Z", "0"-"9" ])+ >| < OBRACKET : "{" >| < CBRACKET : "}" >| < OBRA : "[" >| < CBRA : "]" >| < TD : ":" >| < COMMA : "," >| < QUOTE : "\"" >}SimpleNode Expression() #Start_Exp :{}{  Expression1()  {    return jjtThis;  }}void Expression1() #void :{}{  < OBRACKET > < NODES > < TD > < OBRA > Expression2() < CBRA > < COMMA > < LINKS > < TD > < OBRA > Expression3() < CBRA > < CBRACKET >}void Expression2() #nodes :{}{  Expression4()  (    < COMMA > Expression4()  )*}void Expression3() #links :{}{  Expression5()  (    < COMMA > Expression5()  )*}void Expression4() #node :{}{  < OBRACKET > < NAME > < TD > Expression6() < COMMA > < GROUP > < TD > Expression7() < CBRACKET >}void Expression5() #link :{}{  < OBRACKET > < SOURCE > < TD > Expression7() < COMMA > < TARGET > < TD > Expression7() < COMMA > < VALUE > < TD > Expression7() < CBRACKET >}void Expression6() #void :{  Token t;}{  t = < LETTER > #Name  {    jjtThis.setValues(t);  }}void Expression7() #void :{  Token t;}{  t = < INTEGER > #Int  {    jjtThis.setValues(t);  }}JAVACODE void error_skipto(int kind){  ParseException e = generateParseException(); // generate the exception object.  System.out.println  (    e.toString()  )  ;  Token t;  do  {    t = getNextToken();  }  while (t.kind != kind);}